<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.39">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Final MIMIC-IV Paper</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="Final-Paper_files/libs/clipboard/clipboard.min.js"></script>
<script src="Final-Paper_files/libs/quarto-html/quarto.js"></script>
<script src="Final-Paper_files/libs/quarto-html/popper.min.js"></script>
<script src="Final-Paper_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Final-Paper_files/libs/quarto-html/anchor.min.js"></script>
<link href="Final-Paper_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Final-Paper_files/libs/quarto-html/quarto-syntax-highlighting-e26003cea8cd680ca0c55a263523d882.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Final-Paper_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Final-Paper_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Final-Paper_files/libs/bootstrap/bootstrap-8a79a254b8e706d3c925cde0a310d4f0.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Final MIMIC-IV Paper</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>https://github.com/cmsalgado/book_chapter/blob/master/book_chapter.ipynb &lt;- time series clustering on mimic</p>
<p>13% hospital mortality rate.</p>
<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>Goal: Provide background, define the problem, and state your research objectives.</p>
<p>Problem Statement: Describe why traditional methods fall short and why a framework like ehrapy is valuable.</p>
<p>The increasing digitization of healthcare systems has led to vast collections of electronic health records (EHRs), presenting both opportunities and challenges for medical research [1]. While these datasets contain valuable insights for improving patient care, their heterogeneous nature and lack of standardized analysis approaches have limited their utility [2]. Two recent developments offer promising directions for addressing these challenges: the ehrapy framework, an opensource Python package designed specifically for exploratory analysis of EHR data [2], and advances in machine learning approaches for EHR phenotyping [1]. EHR phenotyping is the process of using electronic health records (EHRs) to identify patients with a specific characteristic or condition. This process is important for research purposes, such as identifying patients for clinical trials.</p>
<p>ehrapy incorporates a series of analytical steps, from data extraction and quality control to the gneration of low-dimension feature representations. Complemented by statistical modules, ehrapy facilitates associating patients with disease states, differential comparison between patient clusters, survival analysis, trajectory inference, causal inference and more. Leveraging ontologies, ehrapy further enables data sharing and training EHR deep learning models, paving the way for foundational models in biomedical research.</p>
<p>The MIMIC-IV clinical database provides an ideal test ground for this work, containing comprehensive clinical data from ICU and non-ICU patients at Beth Israel Deaconess Medical Center <span class="citation" data-cites="johnson2023">(<a href="#ref-johnson2023" role="doc-biblioref">A. E. W. Johnson et al. 2023</a>)</span>. Its structured format and rich clinical information enable direct comparison with analyses performed on the original Pediatric Intensive Care (PIC) database <span class="citation" data-cites="li">(<a href="#ref-li" role="doc-biblioref">Li, Zeng, and Yu 2020</a>)</span>, while its scope and complexity make it suitable for testing advanced machine learning implementations.</p>
<p><strong>Research Objectives:</strong></p>
<ul>
<li><strong>Replication:</strong> Validating ehrapy’s ability to stratify pneumonia patients (adapting the original pediatric analysis to adults in MIMIC-IV).</li>
</ul>
<p>To deepen clinical phenotyping for the disease group ‘unspecified pneumonia’, we calculated a k-nearest neighbor graph to cluster patients into groups and visualize these in UMAP space (Methods). Leiden clustering62 identified four patient groupings with distinct clinical features that we annotated (Fig. 2e). As in the original paper, we will implement the Leiden clustering algorithm to identify subclasses of pneumonia patients in an adult cohort. The Leiden clustering algorithm is a graph-based community detection method used primarily for identifying clusters in complex networks. It’s an improvement upon the popular Louvain algorithm, designed specifically to overcome some of Louvain’s limitations, such as poorly connected or fragmented clusters. - <strong>Extension:</strong> Implementing machine learning (e.g., RNNs) to enhance phenotyping.</p>
<p><strong>Our project had two complementary aims:</strong></p>
<p>First, to validate ehrapy’s effectiveness and generalizability we replicated key analyses from the original paper that had used ehrapy to stratify pediatric patients (PIC database) affected by unspecified pneumonia into finer-grained phenotypes. We validated this work by implementing the same methodology but in an adult cohort and using the MIMIC-IV dataset [3]. Second, we extended the framework by implementing a machine learning approach to predict in-hospital mortality for each of our clustered groups. Our dual approach was used to both validate the original methodological framework and python tools and demonstrate its potential for supporting more sophisticated analytical techniques.</p>
</section>
<section id="background-related-work" class="level1">
<h1>Background &amp; Related Work</h1>
<section id="ehr-phenotyping-briefly-introduce-ehr-phenotyping-why-its-important-common-methods-and-challenges." class="level3">
<h3 class="anchored" data-anchor-id="ehr-phenotyping-briefly-introduce-ehr-phenotyping-why-its-important-common-methods-and-challenges.">EHR Phenotyping: Briefly introduce EHR phenotyping (why it’s important, common methods, and challenges).</h3>
</section>
<section id="machine-learning-in-ehr-analysis-summarize-previous-studies-using-ml-in-phenotyping-clustering-and-classification." class="level3">
<h3 class="anchored" data-anchor-id="machine-learning-in-ehr-analysis-summarize-previous-studies-using-ml-in-phenotyping-clustering-and-classification.">Machine Learning in EHR Analysis: Summarize previous studies using ML in phenotyping, clustering, and classification.</h3>
</section>
<section id="ehrapy-framework-provide-an-overview-of-ehrapy-its-core-functionalities-and-how-it-streamlines-ehr-analysis." class="level3">
<h3 class="anchored" data-anchor-id="ehrapy-framework-provide-an-overview-of-ehrapy-its-core-functionalities-and-how-it-streamlines-ehr-analysis.">ehrapy Framework: Provide an overview of ehrapy, its core functionalities, and how it streamlines EHR analysis.</h3>
<p>For standardized analysis of electronic health record (EHR) data, it is critical that the data are encoded and stored in consistent and resuable formats. For this reason, ehrapy requires that input data are organized in structured vectors. Data loaded into AnnData objects can then be mapped against several hierarchical ontologies (Methods). Clinical keywords of free text notes can automatically be extracted.</p>
<p>Ehrapy is a scalable data storage backend that includes several preprocessing and analysis modules. In ehrapy, data are organized as a data matrix where individual observations (tuples) are individual patient visits, and features () represent all measured quantities. These data matrices are stored together with metadata of observations and features. By leveraging the AnnData annotation structure, ehrapy builds upon established standards and is compatible with analysis and visualization functions provided by the omics scverse <span class="citation" data-cites="virshup2023">(<a href="#ref-virshup2023" role="doc-biblioref">Virshup et al. 2023</a>)</span>.</p>
<p>Powered by scanpy, which scales to millions of observations52 (Methods and Supplementary Table 1) and the machine learning library scikit-learn53, ehrapy provides more than 100 composable analysis functions organized in modules from which custom analysis pipelines can be built. Each function directly interacts with the AnnData object and adds all intermediate results for simple access and reuse of information to it. To facilitate setting up these pipelines, ehrapy guides analysts through a general analysis pipeline (Fig. 1). At any step of an analysis pipeline, community software packages can be integrated without any vendor lock-in. Because ehrapy is built on open standards, it can be purposefully extended to solve new challenges, such as the development of foundational models (Methods).</p>
<p>In the ehrapy analysis pipeline, EHR data are initially inspected for quality issues by analyzing feature distributions that may skew results and by detecting visits and features with high missing rates that ehrapy can then impute (Methods). ehrapy tracks all filtering steps while keeping track of population dynamics to highlight potential selection and filtering biases (Methods). Subsequently, ehrapy’s normalization and encoding functions (Methods) are applied to achieve a uniform numerical representation that facilitates data integration and corrects for dataset shift effects (Methods). Calculated lower-dimensional representations can subsequently be visualized, clustered and annotated to obtain a patient landscape (Methods). Such annotated groups of patients can be used for statistical comparisons to find differences in features among them to ultimately learn markers of patient states. As analysis goals can differ between users and datasets, the ehrapy analysis pipeline is customizable during the final knowledge inference step. ehrapy provides statistical methods for group comparison and extensive support for survival analysis (Methods), enabling the discovery of biomarkers. Furthermore, ehrapy offers functions for causal inference to go from statistically determined associations to causal relations (Methods). Moreover, patient visits in aggregated EHR data can be regarded as snapshots where individual measurements taken at specific timepoints might not adequately reflect the underlying progression of disease and result from unrelated variation due to, for example, day-to-day differences54–56. Therefore, disease progression models should rely on analysis of the underlying clinical data, as disease progression in an individual patient may not be monotonous in time. ehrapy allows for the use of advanced trajectory inference methods to overcome sparse measurements57–59. We show that this approach can order snapshots to calculate a pseudotime that can adequately reflect the progression of the underlying clinical process. Given a sufficient number of snapshots, ehrapy increases the potential to understand disease progression, which is likely not robustly captured within a single EHR but, rather, across several.</p>
</section>
<section id="prior-work-on-pneumonia-phenotyping-pic-study-findings" class="level3">
<h3 class="anchored" data-anchor-id="prior-work-on-pneumonia-phenotyping-pic-study-findings">Prior Work on Pneumonia Phenotyping: PIC study findings:</h3>
<p><span class="citation" data-cites="heumos2024">Heumos et al. (<a href="#ref-heumos2024" role="doc-biblioref">2024</a>)</span> demonstrated the utility of the ehrapy framework by demonstrating capability to analyze heterogeneous datasets from a broad patient set across multiple care units, they applied the ehrapy exploratory strategy to the PIC43 database. The PIC database is a single-center database hosting information on children admitted to critical care units at the Children’s Hospital of Zhejiang University School of Medicine in China.</p>
<p>It contains 13,499 distinct hospital admissions of 12,881 individual pediatric patients admitted between 2010 and 2018 for whom demographics, diagnoses, doctors’ notes, vital signs, laboratory and microbiology tests, medications, fluid balances and more were collected (Extended Data Figs. 1 and 2a and Methods). After missing data imputation and subsequent pre-processing (Extended Data Figs. 2b,c and 3 and Methods), we generated a uniform manifold approximation and projection (UMAP) embedding to visualize variation across all patients using ehrapy (Fig. 2a). This visualization of the low-dimensional patient manifold shows the heterogeneity of the collected data in the PIC database, with malformations, perinatal and respiratory being the most abundant International Classification of Diseases (ICD) chapters (Fig. 2b). The most common respiratory disease categories (Fig. 2c) were labeled pneumonia and influenza (n = 984).</p>
<p>They focused on pneumonia to apply ehrapy to a challenging, broad-spectrum disease that affects all age groups. Pneumonia is a prevalent respiratory infection that poses a substantial burden on public health60 and is characterized by inflammation of the alveoli and distal airways60. Individuals with pre-existing chronic conditions are particularly vulnerable, as are children under the age of 5 (ref. 61). Pneumonia can be caused by a range of microorganisms, encompassing bacteria, respiratory viruses and fungi.influenza</p>
<p><img src="images/paste-2.png" class="img-fluid"></p>
</section>
</section>
<section id="methods" class="level1">
<h1>Methods</h1>
<p>Our investigation was conducted in two phases, first we validated ehrapy’s core functionality through replicating their prior work and then extended it to machine learning-based phenotyping <span class="citation" data-cites="heumos2024">(<a href="#ref-heumos2024" role="doc-biblioref">Heumos et al. 2024</a>)</span>.</p>
<section id="mimic-iv" class="level3">
<h3 class="anchored" data-anchor-id="mimic-iv">MIMIC-IV</h3>
<p>All data utilized in this study were extracted from the MIMIC-IV database version 3.1, containing de-identified health data associated with approximately 50,000 hospital admissions for adult patients between 2008-2019 <span class="citation" data-cites="johnson2023">(<a href="#ref-johnson2023" role="doc-biblioref">A. E. W. Johnson et al. 2023</a>)</span>. The database includes detailed client and hospital level information including patient demographics, vital signs, laboratory measurements, medications, diagnoses, and procedures carried out in both the intensive care unit (ICU), the hospital and emergency department (ED). Credentialed access to MIMIC-IV was obtained through PhysioNet and all analyses was conducted in compliance with the database usage agreement <span class="citation" data-cites="johnson">(<a href="#ref-johnson" role="doc-biblioref">A. Johnson et al. 2023</a>)</span>.</p>
<p>Following the methodology <span class="citation" data-cites="heumos2024">Heumos et al. (<a href="#ref-heumos2024" role="doc-biblioref">2024</a>)</span> , we first set out to validate ehrapy’s basic functionality for cohort identification and characterization by identifying and stratifying adult patients diagnosed with unspecified pneumonia into distinct phenotypic groups <span class="citation" data-cites="johnson">(<a href="#ref-johnson" role="doc-biblioref">A. Johnson et al. 2023</a>)</span>. To do this, we completed the following steps:</p>
<ul>
<li><p>Used ehrapy to prepare and preprocess data (see Fig)</p></li>
<li><p>Use ehrapy’s clustering capabilities to analyze laboratory values, vital signs, and medication patterns <span class="citation" data-cites="heumos2024">(<a href="#ref-heumos2024" role="doc-biblioref">Heumos et al. 2024</a>)</span></p></li>
<li><p>Identify clinically meaningful subgroups in adult pneumonia cases</p></li>
<li><p>Compare findings with the original pediatric patient analysis to evaluate pattern consistency across age groups</p></li>
</ul>
<p><img src="fig3_disease_types_all.png" class="img-fluid"></p>
<p><img src="fig3_pneumonia_subtype.png" class="img-fluid"></p>
<p><img src="fig3_respiratory_subtypes.png" class="img-fluid" width="534"></p>
</section>
<section id="framework-validation-via-patient-stratification" class="level2">
<h2 class="anchored" data-anchor-id="framework-validation-via-patient-stratification">Framework Validation via Patient Stratification</h2>
<ul>
<li>After missing data imputation and subsequent preprocessing (See figures), we generated a uniform manifold approximation and projection (UMAP) embedding to visualize variation across all patients in our cohort using ehrapy.
<ul>
<li>Create UMAP of all patient visits in the ICU with primary discharge diagnosis grouped by ICD grouping. (See original paper and recreate graphs). This visualization of the low-dimensional patient manifold shows the heterogeneity of the collected data in the MIMIC-IV database, with __________, _________ and ______________ being the most abundant ICD chapters.</li>
</ul></li>
</ul>
<p>Clustering Approach: Describe the methods used (e.g., k-means, hierarchical clustering). Evaluation Metrics: How did you assess ehrapy’s stratification performance?</p>
<section id="machine-learning-extension-phase-2" class="level3">
<h3 class="anchored" data-anchor-id="machine-learning-extension-phase-2">Machine Learning Extension (Phase 2)</h3>
<p>Model Selection: Justify the use of RNNs for EHR phenotyping. Feature Engineering: Describe how you converted time-series EHR data into model-ready inputs. Training &amp; Validation: How did you train/test the model? What hyperparameters were used? Performance Metrics: Describe how you evaluated the ML model (e.g., AUC, F1-score, silhouette scores for clustering).</p>
</section>
</section>
<section id="sample-population" class="level2">
<h2 class="anchored" data-anchor-id="sample-population">Sample Population</h2>
</section>
</section>
<section id="results-3-4-pages" class="level1">
<h1>Results (3-4 pages)</h1>
<p><img src="images/paste-1.png" class="img-fluid"></p>
<p>Goal: Present key findings objectively, using figures and tables.</p>
<p><img src="data/visualizations/annotated_leiden_clusters.png" class="img-fluid"> <img src="data/visualizations/PAGA_clusters.png" class="img-fluid"></p>
<section id="validation-results-phase-1" class="level2">
<h2 class="anchored" data-anchor-id="validation-results-phase-1">Validation Results (Phase 1)</h2>
<p>Stratified pneumonia subgroups: Describe the clusters formed and compare them to the original pediatric study. Statistical differences: Highlight major differences/similarities across age groups. ## ML Phenotyping Results (Phase 2)</p>
<p>Performance Metrics: Report accuracy, AUC, or other key metrics of the RNN model. Comparison with Clustering Approach: How well did ML-based phenotyping align with ehrapy’s unsupervised stratification? Visualization: Include figures (e.g., t-SNE plots, confusion matrices).</p>
<section id="ehrapy-framework" class="level3">
<h3 class="anchored" data-anchor-id="ehrapy-framework">Ehrapy framework</h3>
<p>The ehrapy framework was utilized to phenotype adult pneumonia patients using electronic health record (EHR) data. ehrapy provides a modular pipeline designed for standardized data pre-processing and analysis, facilitating reproducibility and collaboration among researchers. The modularity of the framework allows researchers to customize and extend functionality according to specific analytical needs.</p>
<p>Data loading within ehrapy is streamlined through dedicated modules that store structured EHR data in AnnData objects, which support various matrix formats (dense, sparse, ragged) and incorporate comprehensive metadata annotations crucial for cohort tracking and contextual analysis <span class="citation" data-cites="virshup">(<a href="#ref-virshup" role="doc-biblioref">Virshup et al., n.d.</a>)</span>. Cohort tracking functionality in ehrapy enables researchers to systematically follow patient cohorts over time, ensuring accurate longitudinal analyses and facilitating reliable phenotype characterization. For example, we can track all transformations applied to data, making it easier to revert to or visualize original, untransformed values even after extensive processing.</p>
<p>This study will utilize the MIMIC-IV database, which contains de-identified health data associated with approximately 50,000 hospital admissions for adult patients between 2008-2019 <span class="citation" data-cites="johnson">(<a href="#ref-johnson" role="doc-biblioref">A. Johnson et al. 2023</a>)</span>. The database includes detailed information about patient demographics, vital signs, laboratory measurements, medications, diagnoses, and procedures. We have obtained credentialed access to MIMIC-IV through PhysioNet and will conduct all analyses in compliance with the database usage agreement <span class="citation" data-cites="johnson">(<a href="#ref-johnson" role="doc-biblioref">A. Johnson et al. 2023</a>)</span>.</p>
<p><img src="images/paste-3.png" class="img-fluid"></p>

</section>
</section>
</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-heumos2024" class="csl-entry" role="listitem">
Heumos, Lukas, Philipp Ehmele, Tim Treis, Julius Upmeier zu Belzen, Eljas Roellin, Lilly May, Altana Namsaraeva, et al. 2024. <span>“An Open-Source Framework for End-to-End Analysis of Electronic Health Record Data.”</span> <em>Nature Medicine</em> 30 (11): 3369–80. <a href="https://doi.org/10.1038/s41591-024-03214-0">https://doi.org/10.1038/s41591-024-03214-0</a>.
</div>
<div id="ref-johnson2023" class="csl-entry" role="listitem">
Johnson, Alistair E. W., Lucas Bulgarelli, Lu Shen, Alvin Gayles, Ayad Shammout, Steven Horng, Tom J. Pollard, et al. 2023. <span>“MIMIC-IV, a Freely Accessible Electronic Health Record Dataset.”</span> <em>Scientific Data</em> 10 (1): 1. <a href="https://doi.org/10.1038/s41597-022-01899-x">https://doi.org/10.1038/s41597-022-01899-x</a>.
</div>
<div id="ref-johnson" class="csl-entry" role="listitem">
Johnson, Alistair, Lucas Bulgarelli, Tom Pollard, Steven Horng, Leo Anthony Celi, and Roger Mark. 2023. <span>“MIMIC-IV Clinical Database Demo.”</span> <a href="https://doi.org/10.13026/NG9M-3N32">https://doi.org/10.13026/NG9M-3N32</a>.
</div>
<div id="ref-li" class="csl-entry" role="listitem">
Li, Haomin, Xian Zeng, and Gang Yu. 2020. <span>“Paediatric Intensive Care Database.”</span> <em>PhysioNet</em>. <a href="https://doi.org/10.13026/32X9-WV38">https://doi.org/10.13026/32X9-WV38</a>.
</div>
<div id="ref-virshup2023" class="csl-entry" role="listitem">
Virshup, Isaac, Danila Bredikhin, Lukas Heumos, Giovanni Palla, Gregor Sturm, Adam Gayoso, Ilia Kats, et al. 2023. <span>“The Scverse Project Provides a Computational Ecosystem for Single-Cell Omics Data Analysis.”</span> <em>Nature Biotechnology</em> 41 (5): 604–6. <a href="https://doi.org/10.1038/s41587-023-01733-8">https://doi.org/10.1038/s41587-023-01733-8</a>.
</div>
<div id="ref-virshup" class="csl-entry" role="listitem">
Virshup, Isaac, Sergei Rybakov, Fabian J. Theis, Philipp Angerer, and F. Alexander Wolf. n.d. <span>“Anndata: Annotated Data.”</span> <a href="https://doi.org/10.1101/2021.12.16.473007">https://doi.org/10.1101/2021.12.16.473007</a>.
</div>
</div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>